#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main() {
    pid_t child_pid;

    child_pid = fork();

    if (child_pid > 0) {
        // Родительский процесс
        printf("Родительский процесс запущен\n");
        sleep(10); // Подождать 10 секунд, чтобы дать дочернему процессу завершиться
    } else if (child_pid == 0) {
        // Дочерний процесс
        printf("Дочерний процесс запущен\n");
        exit(0); // Дочерний процесс завершается
    }

    return 0;
}
/*
Для создания зомби-процессов можно использовать вызовы fork() и exit() без вызова wait(). Вот пример программы на Си, демонстрирующий зомби-процессы:

c
Copy code
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main() {
    pid_t child_pid;

    child_pid = fork();

    if (child_pid > 0) {
        // Родительский процесс
        printf("Родительский процесс запущен\n");
        sleep(10); // Подождать 10 секунд, чтобы дать дочернему процессу завершиться
    } else if (child_pid == 0) {
        // Дочерний процесс
        printf("Дочерний процесс запущен\n");
        exit(0); // Дочерний процесс завершается
    }

    return 0;
}
Как появляются зомби-процессы:

Зомби-процессы возникают, когда дочерний процесс завершается, но родительский процесс не вызывает wait() 
или waitpid() для получения информации о завершении дочернего процесса. 
В таком случае дочерний процесс остается в состоянии "зомби", 
то есть он завершился, но его ресурсы в ядре все еще заняты, 
и информация о его завершении не была получена родительским процессом.

Чем опасны зомби-процессы:

Зомби-процессы не являются опасными сами по себе, так как они не потребляют ресурсы системы во время выполнения. 
Однако, если их количество становится слишком большим, это может привести к нехватке ресурсов ядра, что может замедлить систему.

Как избавиться от зомби-процессов:

Чтобы избавиться от зомби-процессов, 
родительский процесс должен вызвать wait() или waitpid() для получения информации о завершении дочернего процесса. 
Это позволяет ядру освободить ресурсы, занимаемые зомби-процессом.

В приведенной выше программе, если бы родительский процесс вызвал wait(), 
он бы получил статус завершения дочернего процесса и освободил бы ресурсы, 
занимаемые зомби-процессом.*/